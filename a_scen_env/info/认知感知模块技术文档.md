# è®¤çŸ¥æ„ŸçŸ¥æ¨¡å—æŠ€æœ¯æ–‡æ¡£

## ğŸ“‹ ç›®å½•

1. [æ¨¡å—æ¦‚è¿°](#æ¨¡å—æ¦‚è¿°)
2. [æ ¸å¿ƒè®¾è®¡åŸåˆ™](#æ ¸å¿ƒè®¾è®¡åŸåˆ™)
3. [ç³»ç»Ÿæ¶æ„](#ç³»ç»Ÿæ¶æ„)
4. [æ ¸å¿ƒç±»è¯¦è§£](#æ ¸å¿ƒç±»è¯¦è§£)
5. [å™ªå£°æ¨¡å‹è¯¦è§£](#å™ªå£°æ¨¡å‹è¯¦è§£)
6. [å¡å°”æ›¼æ»¤æ³¢ç³»ç»Ÿ](#å¡å°”æ›¼æ»¤æ³¢ç³»ç»Ÿ)
7. [å¯è§†åŒ–åŠŸèƒ½](#å¯è§†åŒ–åŠŸèƒ½)
8. [é›†æˆä¸ä½¿ç”¨](#é›†æˆä¸ä½¿ç”¨)
9. [é…ç½®å‚æ•°è¯¦è§£](#é…ç½®å‚æ•°è¯¦è§£)
10. [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

---

## ğŸ“– æ¨¡å—æ¦‚è¿°

**è®¤çŸ¥æ„ŸçŸ¥æ¨¡å—** (`cognitive_perception_module.py`) æ˜¯ä¸€ä¸ªé«˜çº§çš„ä¼ æ„Ÿå™¨å™ªå£°æ¨¡æ‹Ÿç³»ç»Ÿï¼Œä¸“é—¨è®¾è®¡ç”¨äºåœ¨MetaDriveè‡ªåŠ¨é©¾é©¶ä»¿çœŸç¯å¢ƒä¸­æ³¨å…¥çœŸå®çš„ä¼ æ„Ÿå™¨å™ªå£°ã€‚è¯¥æ¨¡å—åœ¨**é›·è¾¾ä¼ æ„Ÿå™¨çš„åŸå§‹æµ‹é‡å±‚é¢**æ³¨å…¥å™ªå£°ï¼Œç¡®ä¿å™ªå£°å½±å“çš„æ˜¯ä¼ æ„Ÿå™¨è¾“å‡ºè€Œéç¯å¢ƒçš„ç‰©ç†çŠ¶æ€ã€‚

### ğŸ¯ æ ¸å¿ƒåŠŸèƒ½

- **çœŸå®ä¼ æ„Ÿå™¨å™ªå£°æ¨¡æ‹Ÿ**ï¼šæ¨¡æ‹Ÿé«˜æ–¯æµ‹è·å™ªå£°ã€æ¼æ£€ã€è¯¯æ£€ã€è§’åº¦æŠ–åŠ¨ç­‰çœŸå®é›·è¾¾ä¼ æ„Ÿå™¨ç‰¹æ€§
- **æ™ºèƒ½æ»¤æ³¢ç³»ç»Ÿ**ï¼šé›†æˆå¡å°”æ›¼æ»¤æ³¢å™¨ï¼ˆCVæ¨¡å‹ï¼‰ã€AR(1)æ¨¡å‹ã€ä½é€šæ»¤æ³¢ç­‰å¤šç§æ»¤æ³¢æŠ€æœ¯
- **éä¾µå…¥å¼è®¾è®¡**ï¼šä¸ä¿®æ”¹ç¯å¢ƒç‰©ç†çŠ¶æ€ï¼Œä»…åœ¨ä¼ æ„Ÿå™¨è¾“å‡ºå±‚æ³¨å…¥å™ªå£°
- **å¯è§†åŒ–åˆ†æ**ï¼šæä¾›å™ªå£°æ•ˆæœå¯¹æ¯”å›¾ã€å¡å°”æ›¼æ»¤æ³¢æ€§èƒ½æ—¶åºå›¾ç­‰åˆ†æå·¥å…·
- **çµæ´»é…ç½®**ï¼šæ”¯æŒä¸°å¯Œçš„å‚æ•°é…ç½®ï¼Œé€‚åº”ä¸åŒç ”ç©¶éœ€æ±‚

---

## ğŸ¯ æ ¸å¿ƒè®¾è®¡åŸåˆ™

æ¨¡å—ä¸¥æ ¼éµå¾ªä»¥ä¸‹æ ¸å¿ƒåŸåˆ™ï¼Œç¡®ä¿ä»¿çœŸçš„çœŸå®æ€§å’Œå¯é æ€§ï¼š

### A. ç‰©ç†çŠ¶æ€ä¿æŠ¤åŸåˆ™
- **ç»ä¸ä¿®æ”¹ç¯å¢ƒçœŸå®çŠ¶æ€**ï¼šä¸è°ƒç”¨ä»»ä½•`agent.set_position()`ç­‰ä¼šå½±å“è½¦è¾†åŠ¨åŠ›å­¦ã€ç¢°æ’æ£€æµ‹æˆ–å¥–åŠ±è®¡ç®—çš„æ¥å£
- **ä¿æŒç‰©ç†ä¸€è‡´æ€§**ï¼šç¯å¢ƒçš„ç‰©ç†æ¨¡æ‹Ÿä¿æŒå®Œå…¨çœŸå®ï¼Œå™ªå£°ä»…å­˜åœ¨äºæ„ŸçŸ¥å±‚é¢

### B. ç²¾ç¡®å™ªå£°æ³¨å…¥ä½ç½®
- **ä¼ æ„Ÿå™¨å±‚æ³¨å…¥**ï¼šåœ¨é›·è¾¾ä¼ æ„Ÿå™¨ç±»ï¼ˆ`Lidar`ï¼‰è¾“å‡ºåŸå§‹è·ç¦»æ•°ç»„ï¼ˆç±³ï¼‰**ä¹‹å**ã€è¢«`ObservationManager`å½’ä¸€åŒ–**ä¹‹å‰**æ³¨å…¥å™ªå£°
- **ç±³åˆ¶åŸŸå¤„ç†**ï¼šæ‰€æœ‰å™ªå£°è®¡ç®—å’Œæ»¤æ³¢å¤„ç†éƒ½åœ¨"ç±³"å•ä½çš„åŸå§‹è·ç¦»ä¸Šè¿›è¡Œ

### C. è§‚æµ‹ç»“æ„ä¸å˜åŸåˆ™
- **ä¿æŒæ¥å£ä¸€è‡´æ€§**ï¼šæ— è®ºç¯å¢ƒä½¿ç”¨æ‰å¹³1Dè§‚æµ‹è¿˜æ˜¯å­—å…¸è§‚æµ‹ï¼Œç»“æ„ä¿æŒä¸å˜
- **ä¸Šæ¸¸å™ªå£°ä¼ æ’­**ï¼šå™ªå£°åœ¨ä¼ æ„Ÿå™¨å±‚æ³¨å…¥åï¼Œè‡ªç„¶ä¼ æ’­åˆ°æœ€ç»ˆçš„è§‚æµ‹å‘é‡ä¸­

### D. æ—¶é—´ç›¸å…³æ€§å¤„ç†
- **æ»¤æ³¢å™¨çŠ¶æ€ç®¡ç†**ï¼šå¡å°”æ›¼æ»¤æ³¢ã€AR(1)ç­‰æ—¶é—´ç›¸å…³æ»¤æ³¢åœ¨ç±³åˆ¶åŸå§‹è·ç¦»ä¸Šè¿›è¡Œ
- **çŠ¶æ€é‡ç½®æœºåˆ¶**ï¼šæä¾›`reset()`æ–¹æ³•æ¸…ç©ºæ‰€æœ‰æ»¤æ³¢å™¨çŠ¶æ€

---

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

```mermaid
graph TB
    A[ç‰©ç†ä¸–ç•Œ] --> B[é›·è¾¾å°„çº¿æ£€æµ‹]
    B --> C[åŸå§‹è·ç¦»æµ‹é‡<br/>å•ä½ï¼šç±³]
    C --> D[ğŸ¯ å™ªå£°æ³¨å…¥å±‚<br/>PerceptNoiseLidar]
    D --> E[å½’ä¸€åŒ–å¤„ç†<br/>ObservationManager]
    E --> F[æœ€ç»ˆè§‚æµ‹å‘é‡<br/>Agentè¾“å…¥]
    
    G[CognitivePerceptionModule] --> D
    H[å™ªå£°é…ç½®] --> G
    I[å¡å°”æ›¼æ»¤æ³¢å™¨] --> D
    J[AR1/ä½é€šæ»¤æ³¢] --> D
    
    D --> K[å¯è§†åŒ–ç³»ç»Ÿ]
    K --> L[å™ªå£°å¯¹æ¯”å›¾]
    K --> M[KFæ—¶åºå›¾]
```

### æ•°æ®æµè¯´æ˜

1. **ç‰©ç†ä¸–ç•Œ** â†’ **é›·è¾¾å°„çº¿æ£€æµ‹**ï¼šMetaDriveç‰©ç†å¼•æ“è¿›è¡ŒçœŸå®çš„å°„çº¿æŠ•å°„æ£€æµ‹
2. **åŸå§‹è·ç¦»æµ‹é‡**ï¼šè·å¾—æ¯ä¸ªé›·è¾¾æŸçš„çœŸå®è·ç¦»å€¼ï¼ˆç±³ï¼‰
3. **ğŸ¯ å™ªå£°æ³¨å…¥å±‚**ï¼š`PerceptNoiseLidar`åœ¨æ­¤å±‚æ³¨å…¥å„ç§å™ªå£°æ¨¡å‹
4. **å½’ä¸€åŒ–å¤„ç†**ï¼šMetaDriveçš„`ObservationManager`å°†è·ç¦»å½’ä¸€åŒ–åˆ°[0,1]
5. **æœ€ç»ˆè§‚æµ‹å‘é‡**ï¼šåŒ…å«å™ªå£°å½±å“çš„è§‚æµ‹æ•°æ®ä¼ é€’ç»™æ™ºèƒ½ä½“

---

## ğŸ”§ æ ¸å¿ƒç±»è¯¦è§£

### 1. PerceptNoiseLidar ç±»

**ç»§æ‰¿å…³ç³»**ï¼š`PerceptNoiseLidar` â†’ `Lidar` â†’ `DistanceDetector` â†’ `BaseSensor`

```python
class PerceptNoiseLidar(Lidar):
    """
    å¸¦å™ªå£°çš„é›·è¾¾ä¼ æ„Ÿå™¨ï¼Œç»§æ‰¿MetaDriveçš„Lidarç±»
    åœ¨åŸå§‹è·ç¦»æµ‹é‡ï¼ˆç±³ï¼‰ä¸Šæ³¨å…¥å„ç§å™ªå£°æ¨¡å‹
    """
```

#### ğŸ”‘ å…³é”®æ–¹æ³•

##### `perceive()` - æ ¸å¿ƒå™ªå£°æ³¨å…¥æ–¹æ³•
```python
def perceive(self, physics_world, num_lasers, detector_mask, mask, extra_filter_node, render)
```
- **åŠŸèƒ½**ï¼šé‡å†™çˆ¶ç±»çš„æ„ŸçŸ¥æ–¹æ³•ï¼Œåœ¨è·å¾—åŸå§‹è·ç¦»åæ³¨å…¥å™ªå£°
- **å™ªå£°æ³¨å…¥ä½ç½®**ï¼šåœ¨`super().perceive()`è·å¾—åŸå§‹è·ç¦»åï¼Œè¿”å›ç»™MetaDriveä¹‹å‰
- **å¤„ç†æµç¨‹**ï¼šåŸå§‹è·ç¦» â†’ å™ªå£°æ³¨å…¥ â†’ æ»¤æ³¢å¤„ç† â†’ è¿”å›å¸¦å™ªå£°çš„è·ç¦»

##### `_apply_noise_models()` - å¤šé‡å™ªå£°æ¨¡å‹
```python
def _apply_noise_models(self, distances: np.ndarray, max_range: float) -> np.ndarray
```
- **é«˜æ–¯æµ‹è·å™ªå£°**ï¼š`sigma(d) = sigma0 + k * d`ï¼ˆè·ç¦»è¶Šè¿œå™ªå£°è¶Šå¤§ï¼‰
- **æ¼æ£€æ¨¡æ‹Ÿ**ï¼šä»¥æ¦‚ç‡`p_miss(d)`å°†æ£€æµ‹ç»“æœç½®ä¸ºæœ€å¤§è·ç¦»
- **è¯¯æ£€æ¨¡æ‹Ÿ**ï¼šä»¥æ¦‚ç‡`p_false`ç”Ÿæˆè™šå‡çš„è¿‘è·ç¦»æ£€æµ‹
- **è§’åº¦æŠ–åŠ¨**ï¼šæ¨¡æ‹Ÿä¼ æ„Ÿå™¨å®‰è£…è¯¯å·®å¯¼è‡´çš„è§’åº¦åç§»

##### `_kf_filter()` - å¡å°”æ›¼æ»¤æ³¢ç³»ç»Ÿ
```python
def _kf_filter(self, z_distances: np.ndarray, sigma_array: np.ndarray, return_var: bool = False)
```
- **æ¨¡å‹ç±»å‹**ï¼š1D å¸¸é€Ÿï¼ˆCVï¼‰æ¨¡å‹ï¼Œæ¯ä¸ªé›·è¾¾æŸç‹¬ç«‹æ»¤æ³¢
- **çŠ¶æ€å‘é‡**ï¼š`[ä½ç½®, é€Ÿåº¦]` å¯¹åº” `[è·ç¦», è·ç¦»å˜åŒ–ç‡]`
- **è¾“å‡ºé€‰é¡¹**ï¼šå¯é€‰æ‹©è¿”å›ä½ç½®æ–¹å·®ï¼Œç”¨äºä¸ç¡®å®šæ€§å¯è§†åŒ–

#### ğŸ›ï¸ çŠ¶æ€ç®¡ç†

```python
# æ¯ä¸ªé›·è¾¾æŸç‹¬ç«‹çš„çŠ¶æ€å˜é‡
self.ar1_states = None      # AR(1)å™ªå£°çŠ¶æ€
self.prev_distances = None  # ä¸Šæ¬¡æ»¤æ³¢è·ç¦»
self.kf_state = None        # KFçŠ¶æ€å‘é‡ (N, 2)
self.kf_P = None           # KFåæ–¹å·®çŸ©é˜µ (N, 2, 2)
```

### 2. CognitivePerceptionModule ç±»

**ä¸»æ¥å£ç±»**ï¼Œè´Ÿè´£å°†å™ªå£°é›·è¾¾é›†æˆåˆ°MetaDriveç¯å¢ƒä¸­ã€‚

```python
class CognitivePerceptionModule:
    """
    è®¤çŸ¥æ„ŸçŸ¥æ¨¡å— - ä¸»æ¥å£ç±»
    è´Ÿè´£å°†å™ªå£°é›·è¾¾é›†æˆåˆ°MetaDriveç¯å¢ƒä¸­
    """
```

#### ğŸ”‘ å…³é”®æ–¹æ³•

##### `attach_to_env()` - ä¼ æ„Ÿå™¨æ›¿æ¢
```python
def attach_to_env(self, env)
```
- **åŠŸèƒ½**ï¼šå°†å™ªå£°é›·è¾¾æ›¿æ¢ç¯å¢ƒä¸­çš„åŸå§‹é›·è¾¾ä¼ æ„Ÿå™¨
- **å®ç°æœºåˆ¶**ï¼šä¿®æ”¹`env.engine.sensors["lidar"]`æŒ‡å‘å™ªå£°é›·è¾¾å®ä¾‹
- **å®‰å…¨æ€§**ï¼šä¿å­˜åŸå§‹é›·è¾¾å¼•ç”¨ï¼Œæ”¯æŒæ¢å¤

##### `detach_from_env()` - ä¼ æ„Ÿå™¨æ¢å¤
```python
def detach_from_env(self)
```
- **åŠŸèƒ½**ï¼šæ¢å¤åŸå§‹é›·è¾¾ä¼ æ„Ÿå™¨ï¼Œæ¸…ç†å™ªå£°é›·è¾¾
- **åº”ç”¨åœºæ™¯**ï¼šç¯å¢ƒå…³é—­æ—¶è°ƒç”¨ï¼Œç¡®ä¿ä¸å½±å“åç»­ä½¿ç”¨

##### `generate_visualization()` - å¯è§†åŒ–ç”Ÿæˆ
```python
def generate_visualization(self, env=None, test_distances=None, max_range=50.0)
```
- **æ•°æ®æ¥æº**ï¼šä½¿ç”¨è¿è¡Œæ—¶çš„`PerceptNoiseLidar`å®ä¾‹ï¼Œç¡®ä¿é…ç½®ä¸€è‡´æ€§
- **å›¾è¡¨ç±»å‹**ï¼šå™ªå£°å¯¹æ¯”å›¾ã€å¡å°”æ›¼æ»¤æ³¢æ—¶åºå›¾
- **è¾“å‡ºè·¯å¾„**ï¼šè‡ªåŠ¨ä¿å­˜åˆ°ç¯å¢ƒçš„å¯è§†åŒ–ç›®å½•ä¸‹çš„`cog_influence`æ–‡ä»¶å¤¹

---

## ğŸ² å™ªå£°æ¨¡å‹è¯¦è§£

### 1. é«˜æ–¯æµ‹è·å™ªå£°

**æ•°å­¦æ¨¡å‹**ï¼š
```
Ïƒ(d) = Ïƒâ‚€ + k Ã— d
noise ~ N(0, Ïƒ(d)Â²)
```

**ç‰©ç†æ„ä¹‰**ï¼š
- **Ïƒâ‚€**ï¼šä¼ æ„Ÿå™¨å›ºæœ‰å™ªå£°ï¼ˆä¸è·ç¦»æ— å…³ï¼‰
- **k**ï¼šè·ç¦»ç›¸å…³ç³»æ•°ï¼Œåæ˜ è¿œè·ç¦»æµ‹é‡çš„ä¸ç¡®å®šæ€§å¢åŠ 
- **å…¸å‹å€¼**ï¼šÏƒâ‚€ = 0.1ç±³ï¼Œk = 0.02

**ä»£ç å®ç°**ï¼š
```python
sigma_array = self.sigma0 + self.k * distances
gaussian_noise = np.random.normal(0, sigma_array)
```

### 2. æ¼æ£€æ¨¡å‹

**æ•°å­¦æ¨¡å‹**ï¼š
```
p_miss(d) = p_missâ‚€ Ã— (1 + d/d_far)
```

**ç‰©ç†æ„ä¹‰**ï¼š
- æ¨¡æ‹Ÿé›·è¾¾åœ¨è¿œè·ç¦»æˆ–æ¶åŠ£æ¡ä»¶ä¸‹æ— æ³•æ£€æµ‹åˆ°ç›®æ ‡çš„æƒ…å†µ
- æ¼æ£€æ—¶å°†è¯¥æŸè·ç¦»è®¾ä¸ºæœ€å¤§æ£€æµ‹è·ç¦»ï¼ˆè¡¨ç¤º"æœªæ£€æµ‹åˆ°"ï¼‰

**ä»£ç å®ç°**ï¼š
```python
p_miss = self.p_miss0 * (1 + distances / self.far_distance)
miss_mask = np.random.random(len(distances)) < p_miss
noisy_distances[miss_mask] = max_range
```

### 3. è¯¯æ£€æ¨¡å‹

**æ•°å­¦æ¨¡å‹**ï¼š
```
p_false = å¸¸æ•°
å‡è·ç¦» ~ U(d_near_min, d_near_max)
```

**ç‰©ç†æ„ä¹‰**ï¼š
- æ¨¡æ‹Ÿä¼ æ„Ÿå™¨æ£€æµ‹åˆ°å®é™…ä¸å­˜åœ¨çš„"å¹»å½±"ç›®æ ‡
- é€šå¸¸å‘ç”Ÿåœ¨è¿‘è·ç¦»èŒƒå›´ï¼Œç”±å¤šå¾„åå°„ç­‰å› ç´ é€ æˆ

**ä»£ç å®ç°**ï¼š
```python
false_mask = np.random.random(len(distances)) < self.p_false
false_distances = np.random.uniform(self.near_min, self.near_max, size=np.sum(false_mask))
noisy_distances[false_mask] = false_distances
```

### 4. è§’åº¦æŠ–åŠ¨

**æ•°å­¦æ¨¡å‹**ï¼š
```
jitter ~ U(-jitter_steps, +jitter_steps)
distances_new = roll(distances, jitter)
```

**ç‰©ç†æ„ä¹‰**ï¼š
- æ¨¡æ‹Ÿä¼ æ„Ÿå™¨å®‰è£…è¯¯å·®æˆ–æŒ¯åŠ¨å¯¼è‡´çš„æ•´ä½“è§’åº¦åç§»
- å½±å“æ‰€æœ‰é›·è¾¾æŸçš„è§’åº¦å¯¹åº”å…³ç³»

### 5. æ—¶é—´ç›¸å…³æ€§æ¨¡å‹

#### AR(1) è‡ªå›å½’æ¨¡å‹
```
n_t = Ï Ã— n_{t-1} + âˆš(1-ÏÂ²) Ã— Î¾_t
```
- **Ï**ï¼šè‡ªç›¸å…³ç³»æ•° (0 < Ï < 1)
- **Î¾_t**ï¼šç™½å™ªå£°
- **ç‰¹ç‚¹**ï¼šä¿æŒå™ªå£°çš„æ—¶é—´è¿ç»­æ€§ï¼Œé¿å…çªç„¶è·³è·ƒ

#### ä½é€šæ»¤æ³¢å™¨
```
d_filt_t = Î± Ã— d_noisy_t + (1-Î±) Ã— d_filt_{t-1}
```
- **Î±**ï¼šæ»¤æ³¢ç³»æ•° (0 < Î± < 1)
- **ç‰¹ç‚¹**ï¼šå¹³æ»‘è·ç¦»å˜åŒ–ï¼Œå‡å°‘é«˜é¢‘å™ªå£°

---

## ğŸ” å¡å°”æ›¼æ»¤æ³¢ç³»ç»Ÿ

### æ»¤æ³¢å™¨æ¨¡å‹

**çŠ¶æ€å‘é‡**ï¼š
```
x = [r, á¹™]áµ€    # [è·ç¦», è·ç¦»å˜åŒ–ç‡]
```

**çŠ¶æ€è½¬ç§»çŸ©é˜µ**ï¼š
```
F = [1  Î”t]
    [0   1]
```

**è§‚æµ‹çŸ©é˜µ**ï¼š
```
H = [1  0]
```

**è¿‡ç¨‹å™ªå£°åæ–¹å·®**ï¼š
```
Q = q Ã— [Î”tâ´/4  Î”tÂ³/2]
        [Î”tÂ³/2   Î”tÂ²  ]
```

### æ»¤æ³¢æµç¨‹

1. **é¢„æµ‹æ­¥éª¤**ï¼š
   ```python
   x_pred = F @ x
   P_pred = F @ P @ F.T + Q
   ```

2. **æ›´æ–°æ­¥éª¤**ï¼š
   ```python
   y = z - H @ x_pred           # è§‚æµ‹æ®‹å·®
   S = H @ P_pred @ H.T + R     # æ®‹å·®åæ–¹å·®
   K = P_pred @ H.T @ inv(S)    # å¡å°”æ›¼å¢ç›Š
   x_new = x_pred + K @ y       # çŠ¶æ€æ›´æ–°
   P_new = (I - K @ H) @ P_pred # åæ–¹å·®æ›´æ–°
   ```

### è‡ªé€‚åº”ç‰¹æ€§

- **åŠ¨æ€è§‚æµ‹å™ªå£°**ï¼šæ ¹æ®è·ç¦»è‡ªé€‚åº”è°ƒæ•´è§‚æµ‹å™ªå£° `R = Ïƒ(d)Â²`
- **æ•°å€¼ç¨³å®šæ€§**ï¼šä½¿ç”¨Josephå½¢å¼æ›´æ–°åæ–¹å·®çŸ©é˜µï¼Œæ·»åŠ ä¸‹é™é˜²æ­¢æ•°å€¼é—®é¢˜
- **ç‹¬ç«‹æ»¤æ³¢**ï¼šæ¯ä¸ªé›·è¾¾æŸä½¿ç”¨ç‹¬ç«‹çš„å¡å°”æ›¼æ»¤æ³¢å™¨

---

## ğŸ“Š å¯è§†åŒ–åŠŸèƒ½

### 1. å™ªå£°æ•ˆæœå¯¹æ¯”å›¾

**å›¾è¡¨ç±»å‹**ï¼š`plot_noise_comparison()`

**å†…å®¹åŒ…æ‹¬**ï¼š
- **å­å›¾1**ï¼šé›·è¾¾æŸç´¢å¼• vs è·ç¦»æ›²çº¿ï¼ˆçœŸå®è·ç¦» vs åŠ å™ªè·ç¦»ï¼‰
- **å­å›¾2**ï¼šå™ªå£°åˆ†å¸ƒç›´æ–¹å›¾ + é«˜æ–¯æ‹Ÿåˆæ›²çº¿

**ç¤ºä¾‹è¾“å‡º**ï¼š
```
ğŸ“Š å™ªå£°ç»Ÿè®¡ï¼š
- å¹³å‡å™ªå£°ï¼š-0.045ç±³
- å™ªå£°æ ‡å‡†å·®ï¼š1.234ç±³  
- å™ªå£°èŒƒå›´ï¼š[-3.2, +4.1]ç±³
```

### 2. å¡å°”æ›¼æ»¤æ³¢æ—¶åºå›¾

**å›¾è¡¨ç±»å‹**ï¼š`plot_kf_timeseries()`

**å†…å®¹åŒ…æ‹¬**ï¼š
- **çœŸå€¼æ›²çº¿**ï¼šåœ°é¢çœŸå®è·ç¦»ï¼ˆç»¿è‰²å®çº¿ï¼‰
- **æµ‹é‡æ›²çº¿**ï¼šå¸¦å™ªå£°çš„æµ‹é‡å€¼ï¼ˆçº¢è‰²æ•£ç‚¹ï¼‰
- **ä¼°è®¡æ›²çº¿**ï¼šå¡å°”æ›¼æ»¤æ³¢ä¼°è®¡ï¼ˆè“è‰²å®çº¿ï¼‰
- **ä¸ç¡®å®šæ€§å¸¦**ï¼šÂ±1Ïƒ ç½®ä¿¡åŒºé—´ï¼ˆè“è‰²å¡«å……ï¼‰

**æ€§èƒ½æŒ‡æ ‡**ï¼š
```
ğŸ“ˆ æ»¤æ³¢æ€§èƒ½ï¼š
- æµ‹é‡RMSEï¼š2.957ç±³
- æ»¤æ³¢RMSEï¼š2.934ç±³
- æ”¹å–„ç‡ï¼š0.78%
```

### 3. å¯è§†åŒ–é›†æˆ

**è‡ªåŠ¨åŒ–ç”Ÿæˆ**ï¼š
- ç¯å¢ƒå…³é—­æ—¶è‡ªåŠ¨è°ƒç”¨`generate_visualization()`
- å›¾ç‰‡ä¿å­˜åˆ°`visualization_output_dir/cog_influence/`ç›®å½•
- æ–‡ä»¶ååŒ…å«æ—¶é—´æˆ³ï¼Œé¿å…è¦†ç›–

**é…ç½®ä¸€è‡´æ€§**ï¼š
- ä½¿ç”¨è¿è¡Œæ—¶å®é™…çš„`PerceptNoiseLidar`å®ä¾‹
- ç¡®ä¿å¯è§†åŒ–å‚æ•°ä¸ä»¿çœŸå‚æ•°å®Œå…¨ä¸€è‡´

---

## ğŸ”§ é›†æˆä¸ä½¿ç”¨

### 1. åŸºæœ¬ä½¿ç”¨æµç¨‹

```python
# 1. åˆ›å»ºè®¤çŸ¥æ„ŸçŸ¥æ¨¡å—
perception_module = CognitivePerceptionModule(noise_config)

# 2. åœ¨ç¯å¢ƒresetåé™„åŠ å™ªå£°é›·è¾¾
env.reset()
perception_module.attach_to_env(env)

# 3. æ­£å¸¸è¿è¡Œç¯å¢ƒï¼ˆå™ªå£°è‡ªåŠ¨ç”Ÿæ•ˆï¼‰
for step in range(1000):
    obs, reward, done, info = env.step(action)
    if done:
        break

# 4. ç¯å¢ƒå…³é—­æ—¶åˆ†ç¦»å™ªå£°é›·è¾¾
perception_module.detach_from_env()
env.close()
```

### 2. ä¸TrajectoryReplayEnvCognitiveé›†æˆ

```python
# åœ¨trajectory_replay_cognitive.pyä¸­çš„é›†æˆç¤ºä¾‹
def reset(self):
    obs = super().reset()
    
    # é™„åŠ è®¤çŸ¥æ„ŸçŸ¥æ¨¡å—
    if self.enable_cognitive_modules and self.perception_module:
        self.perception_module.attach_to_env(self)
    
    return obs

def close(self):
    # ç”Ÿæˆå¯è§†åŒ–ï¼ˆåœ¨detachä¹‹å‰ï¼‰
    if self.perception_module:
        self.perception_module.generate_visualization(env=self)
        self.perception_module.detach_from_env()
    
    super().close()
```

### 3. å·¥å‚å‡½æ•°ä½¿ç”¨

```python
# ä¾¿æ·åˆ›å»ºæ–¹æ³•
from cognitive_perception_module import create_cognitive_perception_module

# ä½¿ç”¨é»˜è®¤é…ç½®
module = create_cognitive_perception_module()

# ä½¿ç”¨è‡ªå®šä¹‰é…ç½®
custom_config = {
    'sigma0': 0.2,
    'k': 0.01,
    'p_false': 0.0001,
    'use_kf': True
}
module = create_cognitive_perception_module(custom_config)
```

---

## âš™ï¸ é…ç½®å‚æ•°è¯¦è§£

### åŸºç¡€å™ªå£°å‚æ•°

| å‚æ•° | é»˜è®¤å€¼ | å•ä½ | è¯´æ˜ |
|------|--------|------|------|
| `sigma0` | 0.1 | ç±³ | åŸºç¡€é«˜æ–¯å™ªå£°æ ‡å‡†å·® |
| `k` | 0.02 | - | è·ç¦»ç›¸å…³å™ªå£°ç³»æ•° |
| `p_miss0` | 0.01 | - | åŸºç¡€æ¼æ£€æ¦‚ç‡ |
| `far_distance` | 50.0 | ç±³ | æ¼æ£€æ¦‚ç‡è®¡ç®—çš„è¿œè·ç¦»å‚è€ƒ |
| `p_false` | 0.0001 | - | è¯¯æ£€æ¦‚ç‡ï¼ˆä¿å®ˆå€¼ï¼‰ |
| `near_min` | 1.0 | ç±³ | è¯¯æ£€è·ç¦»æœ€å°å€¼ |
| `near_max` | 5.0 | ç±³ | è¯¯æ£€è·ç¦»æœ€å¤§å€¼ |
| `angle_jitter_steps` | 1 | æŸ | è§’åº¦æŠ–åŠ¨çš„æŸæ•° |

### æ—¶é—´ç›¸å…³æ€§å‚æ•°

| å‚æ•° | é»˜è®¤å€¼ | è¯´æ˜ |
|------|--------|------|
| `use_ar1` | True | å¯ç”¨AR(1)æ¨¡å‹ |
| `rho` | 0.8 | AR(1)è‡ªç›¸å…³ç³»æ•° |
| `use_lowpass` | False | å¯ç”¨ä½é€šæ»¤æ³¢ |
| `alpha` | 0.7 | ä½é€šæ»¤æ³¢ç³»æ•° |

### å¡å°”æ›¼æ»¤æ³¢å‚æ•°

| å‚æ•° | é»˜è®¤å€¼ | å•ä½ | è¯´æ˜ |
|------|--------|------|------|
| `use_kf` | True | - | å¯ç”¨å¡å°”æ›¼æ»¤æ³¢ |
| `kf_dt` | 0.1 | ç§’ | æ»¤æ³¢å™¨æ—¶é—´æ­¥é•¿ |
| `kf_q` | 0.5 | - | è¿‡ç¨‹å™ªå£°è°±å¯†åº¦ |
| `kf_sigma_a` | 3.0 | ç±³/ç§’Â² | åŠ é€Ÿåº¦å™ªå£°æ ‡å‡†å·® |
| `kf_q_scale` | 100.0 | - | è¿‡ç¨‹å™ªå£°ç¼©æ”¾å› å­ |
| `kf_r_floor` | 1e-4 | ç±³Â² | è§‚æµ‹å™ªå£°æ–¹å·®ä¸‹é™ |
| `kf_init_std_pos` | 5.0 | ç±³ | åˆå§‹ä½ç½®ä¸ç¡®å®šæ€§ |
| `kf_init_std_vel` | 10.0 | ç±³/ç§’ | åˆå§‹é€Ÿåº¦ä¸ç¡®å®šæ€§ |

### é…ç½®ä¼˜åŒ–å»ºè®®

#### ä¿å®ˆé…ç½®ï¼ˆé€‚åˆåˆå§‹æµ‹è¯•ï¼‰
```python
conservative_config = {
    'sigma0': 0.05,     # è¾ƒå°çš„åŸºç¡€å™ªå£°
    'k': 0.01,          # è¾ƒå°çš„è·ç¦»ç³»æ•°
    'p_false': 0.0001,  # å¾ˆä½çš„è¯¯æ£€ç‡
    'p_miss0': 0.005,   # è¾ƒä½çš„æ¼æ£€ç‡
    'use_kf': True,     # å¯ç”¨æ»¤æ³¢
    'kf_q': 0.1         # è¾ƒå¼ºçš„æ»¤æ³¢
}
```

#### æ¿€è¿›é…ç½®ï¼ˆé€‚åˆé²æ£’æ€§æµ‹è¯•ï¼‰
```python
aggressive_config = {
    'sigma0': 0.3,      # è¾ƒå¤§çš„åŸºç¡€å™ªå£°
    'k': 0.05,          # è¾ƒå¤§çš„è·ç¦»ç³»æ•°
    'p_false': 0.001,   # ä¸­ç­‰è¯¯æ£€ç‡
    'p_miss0': 0.02,    # ä¸­ç­‰æ¼æ£€ç‡
    'use_kf': True,     # å¯ç”¨æ»¤æ³¢
    'kf_q': 1.0         # è¾ƒå¼±çš„æ»¤æ³¢
}
```

---

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. å‚æ•°è°ƒä¼˜ç­–ç•¥

**æ¸è¿›å¼è°ƒä¼˜**ï¼š
1. ä»ä¿å®ˆé…ç½®å¼€å§‹
2. é€æ­¥å¢åŠ å™ªå£°å¼ºåº¦
3. è§‚å¯Ÿå¯è§†åŒ–ç»“æœè°ƒæ•´å‚æ•°
4. éªŒè¯æ™ºèƒ½ä½“æ€§èƒ½å½±å“

**å…³é”®æŒ‡æ ‡ç›‘æ§**ï¼š
- å™ªå£°åˆ†å¸ƒçš„åˆç†æ€§ï¼ˆå‡å€¼æ¥è¿‘0ï¼‰
- å¡å°”æ›¼æ»¤æ³¢çš„æ”¶æ•›æ€§
- æ™ºèƒ½ä½“å†³ç­–çš„ç¨³å®šæ€§

### 2. è°ƒè¯•æŠ€å·§

**å¯è§†åŒ–éªŒè¯**ï¼š
```python
# ç”Ÿæˆå¯è§†åŒ–å›¾è¡¨è¿›è¡Œå‚æ•°éªŒè¯
module.generate_visualization(env, test_distances, max_range=50.0)
```

**æ—¥å¿—ç›‘æ§**ï¼š
```python
import logging
logging.basicConfig(level=logging.INFO)
# è§‚å¯Ÿæ¨¡å—åˆå§‹åŒ–å’Œè¿è¡Œæ—¥å¿—
```

**æ€§èƒ½åˆ†æ**ï¼š
```python
# å¯¹æ¯”å¼€å¯/å…³é—­å™ªå£°çš„æ™ºèƒ½ä½“æ€§èƒ½
no_noise_rewards = evaluate_agent(env_clean)
with_noise_rewards = evaluate_agent(env_noisy)
```

### 3. å¸¸è§é—®é¢˜è§£å†³

**é—®é¢˜1ï¼šå™ªå£°è¿‡å¤§å¯¼è‡´æ™ºèƒ½ä½“æ€§èƒ½ä¸¥é‡ä¸‹é™**
- **è§£å†³**ï¼šå‡å°`sigma0`å’Œ`k`å‚æ•°ï¼Œå¯ç”¨å¡å°”æ›¼æ»¤æ³¢

**é—®é¢˜2ï¼šè¯¯æ£€ç‡è¿‡é«˜å½±å“å¯¼èˆª**
- **è§£å†³**ï¼šé™ä½`p_false`å‚æ•°ï¼ˆå»ºè®®<0.001ï¼‰

**é—®é¢˜3ï¼šå¡å°”æ›¼æ»¤æ³¢ä¸æ”¶æ•›**
- **è§£å†³**ï¼šè°ƒæ•´`kf_q`å‚æ•°ï¼Œå¢åŠ `kf_r_floor`é˜²æ­¢æ•°å€¼é—®é¢˜

**é—®é¢˜4ï¼šå¯è§†åŒ–å›¾ç‰‡æœªç”Ÿæˆ**
- **è§£å†³**ï¼šç¡®ä¿ç¯å¢ƒæ­£ç¡®è°ƒç”¨`generate_visualization()`ï¼Œæ£€æŸ¥æƒé™

### 4. æ€§èƒ½ä¼˜åŒ–

**å†…å­˜ä¼˜åŒ–**ï¼š
- åˆç†è®¾ç½®é›·è¾¾æŸæ•°ï¼Œé¿å…è¿‡å¤šçŠ¶æ€å˜é‡
- åŠæ—¶è°ƒç”¨`reset()`æ¸…ç†æ»¤æ³¢å™¨çŠ¶æ€

**è®¡ç®—ä¼˜åŒ–**ï¼š
- å¡å°”æ›¼æ»¤æ³¢ä½¿ç”¨å‘é‡åŒ–è®¡ç®—
- é¿å…åœ¨æ¯æ­¥éƒ½è¿›è¡Œå¤æ‚çš„å™ªå£°è®¡ç®—

**å¯æ‰©å±•æ€§**ï¼š
- æ¨¡å—åŒ–è®¾è®¡æ”¯æŒæ·»åŠ æ–°çš„å™ªå£°æ¨¡å‹
- é…ç½®é©±åŠ¨çš„å‚æ•°ç®¡ç†ä¾¿äºä¸åŒåœºæ™¯åˆ‡æ¢

---

## ğŸ”¬ æŠ€æœ¯ç‰¹è‰²

### 1. éä¾µå…¥å¼è®¾è®¡
- **é›¶å½±å“åŸåˆ™**ï¼šä¸ä¿®æ”¹MetaDriveçš„æ ¸å¿ƒä»£ç 
- **æ’ä»¶å¼é›†æˆ**ï¼šé€šè¿‡ä¼ æ„Ÿå™¨æ›¿æ¢å®ç°å™ªå£°æ³¨å…¥
- **å¯é€†æ“ä½œ**ï¼šæ”¯æŒå®Œå…¨æ¢å¤åˆ°åŸå§‹çŠ¶æ€

### 2. ç§‘å­¦ä¸¥è°¨çš„å™ªå£°å»ºæ¨¡
- **ç‰©ç†åŸºç¡€**ï¼šåŸºäºçœŸå®ä¼ æ„Ÿå™¨ç‰¹æ€§å»ºæ¨¡
- **æ•°å­¦ä¸¥æ ¼**ï¼šæ‰€æœ‰å™ªå£°æ¨¡å‹éƒ½æœ‰æ˜ç¡®çš„æ•°å­¦è¡¨è¾¾
- **ç»Ÿè®¡æœ‰æ•ˆ**ï¼šå™ªå£°åˆ†å¸ƒç¬¦åˆå®é™…ä¼ æ„Ÿå™¨ç»Ÿè®¡ç‰¹æ€§

### 3. å…ˆè¿›çš„æ»¤æ³¢æŠ€æœ¯
- **å¤šæ¨¡å‹æ”¯æŒ**ï¼šå¡å°”æ›¼æ»¤æ³¢ã€AR(1)ã€ä½é€šæ»¤æ³¢
- **è‡ªé€‚åº”ç‰¹æ€§**ï¼šæ ¹æ®è·ç¦»åŠ¨æ€è°ƒæ•´å™ªå£°å‚æ•°
- **æ•°å€¼ç¨³å®š**ï¼šè€ƒè™‘æ•°å€¼ç²¾åº¦å’Œç¨³å®šæ€§é—®é¢˜

### 4. å®Œå–„çš„åˆ†æå·¥å…·
- **å®æ—¶å¯è§†åŒ–**ï¼šè¿è¡Œæ—¶ç”Ÿæˆåˆ†æå›¾è¡¨
- **å®šé‡è¯„ä¼°**ï¼šæä¾›è¯¦ç»†çš„ç»Ÿè®¡æŒ‡æ ‡
- **è°ƒè¯•å‹å¥½**ï¼šä¸°å¯Œçš„æ—¥å¿—å’Œé”™è¯¯å¤„ç†

---

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. **ä¼ æ„Ÿå™¨å™ªå£°å»ºæ¨¡**ï¼š
   - "Probabilistic Robotics" by Thrun, Burgard, and Fox
   - "Radar Signal Processing" by Richards et al.

2. **å¡å°”æ›¼æ»¤æ³¢ç†è®º**ï¼š
   - "Optimal State Estimation" by Dan Simon
   - "Introduction to Random Signals and Applied Kalman Filtering" by Brown & Hwang

3. **MetaDriveæ–‡æ¡£**ï¼š
   - [MetaDrive Official Documentation](https://metadrive-simulator.readthedocs.io/)
   - [MetaDrive GitHub Repository](https://github.com/metadriverse/metadrive)

---

## ğŸ“ æŠ€æœ¯æ”¯æŒ

å¦‚éœ€æŠ€æœ¯æ”¯æŒæˆ–æŠ¥å‘Šé—®é¢˜ï¼Œè¯·å‚è€ƒï¼š

1. **æ¨¡å—æ—¥å¿—**ï¼šæŸ¥çœ‹è¯¦ç»†çš„è¿è¡Œæ—¥å¿—ä¿¡æ¯
2. **å¯è§†åŒ–è¾“å‡º**ï¼šåˆ†æç”Ÿæˆçš„å›¾è¡¨æ–‡ä»¶
3. **é…ç½®éªŒè¯**ï¼šç¡®è®¤å‚æ•°è®¾ç½®çš„åˆç†æ€§
4. **æ€§èƒ½ç›‘æ§**ï¼šå¯¹æ¯”å™ªå£°å‰åçš„ç³»ç»Ÿæ€§èƒ½

---

*æœ¬æ–‡æ¡£ç‰ˆæœ¬ï¼šv1.0 | æœ€åæ›´æ–°ï¼š2025-01-15* 